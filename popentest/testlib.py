# -*- coding: utf-8 -*-
# 百度使用的oss是华为云的，https://support.huaweicloud.com/sdk-python-devg-obs/obs_22_0002.html
# pip install esdk-obs-python
from obs import ObsClient, PutObjectHeader, DeleteObjectsRequest, Object 

import traceback
import os
import shutil

import logging
logger = logging.getLogger(__name__)

class MyObsClient(object):
    # endpoint = "http://gqjt.com"
    # ak = "CB350C40B87AA1F98EC4"
    # sk = "po31sdnqhaYU6xV3Y2daLNHruxMAAAGEuHqh+fPl"
    # debug 是否显示错误提示 True 显示 False 不显示
    def __init__(self, ak, sk, server, debug=True):
        self._client = ObsClient(
            access_key_id=ak, 
            secret_access_key=sk, 
            server=server
        )
        self._ak = ak
        self._sk = sk
        self._server = server
        self._debug = debug

    
    # 上传文件
    # bucket：桶名，目前写死 x8v-drivingcloud-xtest
    # name：存储在对象存储里的key
    # path: 要上传的本地文件地址
    # def put_object(self, bucket, name, path):
    #     self._client.fput_object(
    #         bucket,
    #         name,
    #         path
    #     )

    # 创建桶
    # bucket 桶名
    # return True 创建成功 False 创建失败
    def create_bucket(self, bucket):
        resp = self._client.createBucket(bucket)
        if resp.status < 300:
            if self._debug:
                print('Create bucket:' + bucket + ' successfully!\n')

            return True
        else:
            if self._debug:
                print(resp.errorCode)

            return False

    # 在指定的bucket下创建目录
    # bucket 桶名
    # folder 目录名
    def create_folder(self, bucket, folder):
        resp = self._client.putContent(bucket, folder, '')
        if self._debug:
            print(resp)

        if resp['reason'] == 'OK':
            return True
        return False

    # 列出桶下指定目录的所有文件名，用来验证是否上传正确
    # buckerName 桶名
    # folder  指定的目录名
    def list_folder(self, bucketName, folder):
        resp = self._client.listObjects(bucketName, folder)
        if self._debug:
            print(resp)
            print('requestId:', resp.requestId) 
            print('name:', resp.body.name) 
            print('prefix:', resp.body.prefix) 
            print('max_keys:', resp.body.max_keys) 
            # print('is_truncated:', resp.body.is_truncated) 

        for content in resp.body.contents:
            if self._debug:
                print('\t' + content.key + ' etag[' + content.etag + ']')

    # 上传文件
    # bucketName x8v-drivingcloud-xtest
    # objectKey：存储在对象存储里的key
    # sampleFilePath: 要上传的本地文件地址
    # return True 上传成功  False 上传失败
    def put_file(self, bucketName, objectKey, sampleFilePath):
        try:
            headers = PutObjectHeader() 
            headers.contentType = 'text/plain' 
            
            resp = self._client.putFile(
                bucketName, 
                objectKey, 
                sampleFilePath,
                headers=headers
            ) 
                
            if resp.status < 300: 
                if self._debug:
                    print('requestId:', resp.requestId) 
                    print('etag:', resp.body.etag) 
                    print('versionId:', resp.body.versionId) 
                    print('storageClass:', resp.body.storageClass) 

                return True
            else: 
                if self._debug:
                    print('errorCode:', resp.errorCode) 
                    print('errorMessage:', resp.errorMessage)
                return False
        except Exception as e:
            if self._debug:
                print(traceback.format_exc())
                logger.error(traceback.format_exc())
            return False

    # 把本地目录下的所有内容传输到folder下
    # bucketName: 桶名 
    # folder: 对象存储里的目录
    # sampleDir: 本地目录
    def put_object(self, bucketName, folder, sampleDir):
        self.create_folder(bucket=bucketName, folder=folder)

        origin_folder = folder
        if os.path.isdir(sampleDir):
            files = os.listdir(sampleDir)

            for fi in files:
                filePath = "%s/%s" % (sampleDir, fi)

                obsKey = "%s/%s" % (folder, fi)    
                if self._debug:
                    print("update obsKey=%s  filepath=%s" % (obsKey, filePath))

                if os.path.isfile(filePath):                    
                    if self._debug:
                        print("put file to %s %s" % (obsKey, filePath))

                    self.put_file(bucketName=bucketName, objectKey=obsKey, sampleFilePath=filePath)
                    
                    obsKey = origin_folder
                    self.put_object(bucketName, obsKey, filePath)

                if os.path.isdir(filePath):
                    if self._debug:
                        print("create dir to %s %s" % (obsKey, filePath))

                    self.create_folder(bucket=bucketName, folder=obsKey)
                    self.put_object(bucketName, obsKey, filePath)
                    

    # 从指定桶里下载文件
    # bucketName: 桶名
    # objectName: 对象存储上的key
    # path: 存储到本地的地址
    # return True 下载成功 False 下载失败
    def download_file(self, bucketName, objectName, path):
        try:
            resp = self._client.getObject(bucketName, objectName, downloadPath=path) 
                
            if resp.status < 300: 
                if self._debug:
                    print('requestId:', resp.requestId) 
                    print('url:', resp.body.url) 

                return True
            else: 
                if self._debug:
                    print('errorCode:', resp.errorCode) 
                    print('errorMessage:', resp.errorMessage)

                return False
        except:
            if self._debug:
                print(traceback.format_exc())
            
            logger.error(traceback.format_exc())
            return False


    # 下载对象存储上的一个整个目录到本地
    # bucketName: 桶名
    # folder: 对象存储的目录
    # savePath: 要保存到本地目录地址
    def download_folder(self, bucketName, folder, savePath):
        resp = self._client.listObjects(bucketName, folder)
        # print(resp)

        # for content in resp.body.contents:
        #     # saimo_scene_id/ etag["00000000000000000000000000000000"]
        #     print('\t' + content.key + ' etag[' + content.etag + ']')

        for content in resp.body.contents:
            key = content.key
            # print("key is %s" % key)

            if key.find(".") == -1:
                targetPath = "%s%s" % (savePath, key)
                # print("create pash is %s" % targetPath)
                # targetPath = "%s%s" % (savePath, content)
                if not os.path.isdir(targetPath):
                    os.makedirs(targetPath)
            else:
                # subPathStr = "/".join(subPaths)
                targetPath = "%s%s" % (savePath, key)

                if self._debug:
                    print("---" * 10)
                    print("save %s to %s" % (key, savePath))

                self.download_file(bucketName=bucketName, objectName=key, path=targetPath)


    # 删除对象文件，慎用
    # bucketName: 要删除的文件所在的桶
    # objeckKey: 要删除的对象key
    # return True: 返回成功  False: 返回失败
    def delete_object(self, bucketName, objectKey, versionId=None):
        try:
            resp = self._client.deleteObject(bucketName, objectKey, versionId=versionId) 
                
            if resp.status < 300: 
                if self._debug:
                    print('requestId:', resp.requestId) 
                    print('deleteMarker:', resp.body.deleteMarker) 
                    print('versionId:', resp.body.versionId) 
                return True
            else: 
                if self._debug:
                    print('errorCode:', resp.errorCode) 
                    print('errorMessage:', resp.errorMessage)
                return False
        except:
            if self._debug:
                print(traceback.format_exc())

            logger.error(traceback.format_exc())
            return False
            

# if __name__ == '__main__':
#     endpoint = "http://gqjt.com"
#     bucket = "x8v-drivingcloud-xtest"
#     ak = "CB350C40B87AA1F98EC4"
#     sk = "po31sdnqhaYU6xV3Y2daLNHruxMAAAGEuHqh+fPl"

#     client = MyObsClient(sk=sk, ak=ak, server=endpoint)

#     # print(obsKey)
#     obsKey = "matlab"
#     path = "/Users/guohuang/Downloads/matlab2016b.tar.gz"    
#     client.put_file(bucket, obsKey, path)
